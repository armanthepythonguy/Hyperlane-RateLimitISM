import { Debugger } from 'debug';
import { BigNumber, ContractReceipt, ContractTransaction, PopulatedTransaction, Signer, providers } from 'ethers';
import { Address } from '@hyperlane-xyz/utils';
import { ChainMetadataManager } from '../metadata/ChainMetadataManager';
import { ChainMetadata } from '../metadata/chainMetadataTypes';
import { ChainMap, ChainName } from '../types';
import { ProviderBuilderFn } from './providerBuilders';
type Provider = providers.Provider;
export interface MultiProviderOptions {
    loggerName?: string;
    providers?: ChainMap<Provider>;
    providerBuilder?: ProviderBuilderFn<Provider>;
    signers?: ChainMap<Signer>;
}
/**
 * A utility class to create and manage providers and signers for multiple chains
 * @typeParam MetaExt - Extra metadata fields for chains (such as contract addresses)
 */
export declare class MultiProvider<MetaExt = {}> extends ChainMetadataManager<MetaExt> {
    readonly options: MultiProviderOptions;
    readonly providers: ChainMap<Provider>;
    readonly providerBuilder: ProviderBuilderFn<Provider>;
    signers: ChainMap<Signer>;
    useSharedSigner: boolean;
    readonly logger: Debugger;
    /**
     * Create a new MultiProvider with the given chainMetadata,
     * or the SDK's default metadata if not provided
     */
    constructor(chainMetadata?: ChainMap<ChainMetadata<MetaExt>>, options?: MultiProviderOptions);
    addChain(metadata: ChainMetadata<MetaExt>): void;
    extendChainMetadata<NewExt = {}>(additionalMetadata: ChainMap<NewExt>): MultiProvider<MetaExt & NewExt>;
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     */
    tryGetProvider(chainNameOrId: ChainName | number): Provider | null;
    /**
     * Get an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getProvider(chainNameOrId: ChainName | number): Provider;
    /**
     * Sets an Ethers provider for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    setProvider(chainNameOrId: ChainName | number, provider: Provider): Provider;
    /**
     * Sets Ethers providers for a set of chains
     * @throws if chain's metadata has not been set
     */
    setProviders(providers: ChainMap<Provider>): void;
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     */
    tryGetSigner(chainNameOrId: ChainName | number): Signer | null;
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * If signer is not yet connected, it will be connected
     * @throws if chain's metadata or signer has not been set
     */
    getSigner(chainNameOrId: ChainName | number): Signer;
    /**
     * Get an Ethers signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata or signer has not been set
     */
    getSignerAddress(chainNameOrId: ChainName | number): Promise<Address>;
    /**
     * Sets an Ethers Signer for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigner(chainNameOrId: ChainName | number, signer: Signer): Signer;
    /**
     * Sets Ethers Signers for a set of chains
     * @throws if chain's metadata has not been set or shared signer has already been set
     */
    setSigners(signers: ChainMap<Signer>): void;
    /**
     * Gets the Signer if it's been set, otherwise the provider
     */
    tryGetSignerOrProvider(chainNameOrId: ChainName | number): Signer | Provider | null;
    /**
     * Gets the Signer if it's been set, otherwise the provider
     * @throws if chain metadata has not been set
     */
    getSignerOrProvider(chainNameOrId: ChainName | number): Signer | Provider;
    /**
     * Sets Ethers Signers to be used for all chains
     * Any subsequent calls to getSigner will return given signer
     * Setting sharedSigner to null clears all signers
     */
    setSharedSigner(sharedSigner: Signer | null): Signer | null;
    /**
     * Create a new MultiProvider from the intersection
     * of current's chains and the provided chain list
     */
    intersect(chains: ChainName[], throwIfNotSubset?: boolean): {
        intersection: ChainName[];
        result: MultiProvider<MetaExt>;
    };
    /**
     * Get a block explorer URL for given chain's address
     */
    tryGetExplorerAddressUrl(chainNameOrId: ChainName | number, address?: string): Promise<string | null>;
    /**
     * Get the transaction overrides for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getTransactionOverrides(chainNameOrId: ChainName | number): Partial<providers.TransactionRequest>;
    /**
     * Wait for given tx to be confirmed
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    handleTx(chainNameOrId: ChainName | number, tx: ContractTransaction | Promise<ContractTransaction>): Promise<ContractReceipt>;
    /**
     * Populate a transaction's fields using signer address and overrides
     * @throws if chain's metadata has not been set or tx fails
     */
    prepareTx(chainNameOrId: ChainName | number, tx: PopulatedTransaction, from?: string): Promise<providers.TransactionRequest>;
    /**
     * Estimate gas for given tx
     * @throws if chain's metadata has not been set or tx fails
     */
    estimateGas(chainNameOrId: ChainName | number, tx: PopulatedTransaction, from?: string): Promise<BigNumber>;
    /**
     * Send a transaction and wait for confirmation
     * @throws if chain's metadata or signer has not been set or tx fails
     */
    sendTransaction(chainNameOrId: ChainName | number, tx: PopulatedTransaction): Promise<ContractReceipt>;
    /**
     * Creates a MultiProvider using the given signer for all test networks
     */
    static createTestMultiProvider(params?: {
        signer?: Signer;
        provider?: Provider;
    }, chains?: ChainName[]): MultiProvider;
}
export {};
//# sourceMappingURL=MultiProvider.d.ts.map