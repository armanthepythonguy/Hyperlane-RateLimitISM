"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiProtocolProvider = exports.PROTOCOL_DEFAULT_PROVIDER_TYPE = void 0;
const debug_1 = require("debug");
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../consts/chainMetadata");
const ChainMetadataManager_1 = require("../metadata/ChainMetadataManager");
const MultiProvider_1 = require("./MultiProvider");
const ProviderType_1 = require("./ProviderType");
const providerBuilders_1 = require("./providerBuilders");
exports.PROTOCOL_DEFAULT_PROVIDER_TYPE = {
    [utils_1.ProtocolType.Ethereum]: ProviderType_1.ProviderType.EthersV5,
    [utils_1.ProtocolType.Sealevel]: ProviderType_1.ProviderType.SolanaWeb3,
};
/**
 * A version of MultiProvider that can support different
 * provider types across different protocol types.
 *
 * This uses a different interface for provider/signer related methods
 * so it isn't strictly backwards compatible with MultiProvider.
 *
 * Unlike MultiProvider, this class does not support signer/signing methods (yet).
 * @typeParam MetaExt - Extra metadata fields for chains (such as contract addresses)
 */
class MultiProtocolProvider extends ChainMetadataManager_1.ChainMetadataManager {
    constructor(chainMetadata = chainMetadata_1.chainMetadata, options = {}) {
        super(chainMetadata, options);
        this.options = options;
        // Chain name -> provider type -> signer
        this.signers = {}; // TODO signer support
        this.logger = (0, debug_1.debug)(options?.loggerName || 'hyperlane:MultiProtocolProvider');
        this.providers = options.providers || {};
        this.providerBuilders =
            options.providerBuilders || providerBuilders_1.defaultProviderBuilderMap;
    }
    static fromMultiProvider(mp, options = {}) {
        const newMp = new MultiProtocolProvider(mp.metadata, options);
        const typedProviders = (0, utils_1.objMap)(mp.providers, (_, provider) => ({
            type: ProviderType_1.ProviderType.EthersV5,
            provider,
        }));
        newMp.setProviders(typedProviders);
        return newMp;
    }
    toMultiProvider(options) {
        const newMp = new MultiProvider_1.MultiProvider(this.metadata, options);
        const providers = (0, utils_1.objMap)(this.providers, (_, typeToProviders) => typeToProviders[ProviderType_1.ProviderType.EthersV5]?.provider);
        const filteredProviders = (0, utils_1.objFilter)(providers, (_, p) => !!p);
        newMp.setProviders(filteredProviders);
        return newMp;
    }
    extendChainMetadata(additionalMetadata) {
        const newMetadata = super.extendChainMetadata(additionalMetadata).metadata;
        const newMp = new MultiProtocolProvider(newMetadata, {
            ...this.options,
            providers: this.providers,
        });
        return newMp;
    }
    tryGetProvider(chainNameOrId, type) {
        var _a;
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        if (!metadata)
            return null;
        const { protocol, name, chainId, rpcUrls } = metadata;
        type = type || exports.PROTOCOL_DEFAULT_PROVIDER_TYPE[protocol];
        if (!type)
            return null;
        if (this.providers[name]?.[type])
            return this.providers[name][type];
        const builder = this.providerBuilders[type];
        if (!rpcUrls.length || !builder)
            return null;
        const provider = builder(rpcUrls, chainId);
        (_a = this.providers)[name] || (_a[name] = {});
        this.providers[name][type] = provider;
        return provider;
    }
    getProvider(chainNameOrId, type) {
        const provider = this.tryGetProvider(chainNameOrId, type);
        if (!provider)
            throw new Error(`No provider available for ${chainNameOrId}`);
        return provider;
    }
    getEthersV5Provider(chainNameOrId) {
        const provider = this.getProvider(chainNameOrId, ProviderType_1.ProviderType.EthersV5);
        if (provider.type !== ProviderType_1.ProviderType.EthersV5)
            throw new Error('Invalid provider type');
        return provider.provider;
    }
    // getEthersV6Provider(
    //   chainNameOrId: ChainName | number,
    // ): EthersV6Provider['provider'] {
    //   const provider = this.getProvider(chainNameOrId, ProviderType.EthersV6);
    //   if (provider.type !== ProviderType.EthersV6)
    //     throw new Error('Invalid provider type');
    //   return provider.provider;
    // }
    getViemProvider(chainNameOrId) {
        const provider = this.getProvider(chainNameOrId, ProviderType_1.ProviderType.Viem);
        if (provider.type !== ProviderType_1.ProviderType.Viem)
            throw new Error('Invalid provider type');
        return provider.provider;
    }
    getSolanaWeb3Provider(chainNameOrId) {
        const provider = this.getProvider(chainNameOrId, ProviderType_1.ProviderType.SolanaWeb3);
        if (provider.type !== ProviderType_1.ProviderType.SolanaWeb3)
            throw new Error('Invalid provider type');
        return provider.provider;
    }
    setProvider(chainNameOrId, provider) {
        var _a;
        const chainName = this.getChainName(chainNameOrId);
        (_a = this.providers)[chainName] || (_a[chainName] = {});
        this.providers[chainName][provider.type] = provider;
        return provider;
    }
    setProviders(providers) {
        for (const chain of Object.keys(providers)) {
            this.setProvider(chain, providers[chain]);
        }
    }
    intersect(chains, throwIfNotSubset = false) {
        const { intersection, result } = super.intersect(chains, throwIfNotSubset);
        const multiProvider = new MultiProtocolProvider(result.metadata, {
            ...this.options,
            providers: (0, utils_1.pick)(this.providers, intersection),
        });
        return { intersection, result: multiProvider };
    }
}
exports.MultiProtocolProvider = MultiProtocolProvider;
//# sourceMappingURL=MultiProtocolProvider.js.map