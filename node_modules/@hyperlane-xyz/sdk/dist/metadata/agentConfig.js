"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAgentConfig = exports.buildAgentConfigDeprecated = exports.buildAgentConfigNew = exports.ValidatorAgentConfigSchema = exports.ScraperAgentConfigSchema = exports.RelayerAgentConfigSchema = exports.AgentConfigSchema = exports.AgentChainMetadataSchema = exports.AgentSignerSchema = exports.AgentIndexMode = exports.AgentLogFormat = exports.AgentLogLevel = exports.AgentConsensusType = exports.AgentConnectionType = void 0;
/**
 * The types defined here are the source of truth for chain metadata.
 * ANY CHANGES HERE NEED TO BE REFLECTED IN HYPERLANE-BASE CONFIG PARSING.
 */
const zod_1 = require("zod");
const chainMetadataTypes_1 = require("./chainMetadataTypes");
const customZodTypes_1 = require("./customZodTypes");
const deploymentArtifacts_1 = require("./deploymentArtifacts");
const matchingList_1 = require("./matchingList");
var AgentConnectionType;
(function (AgentConnectionType) {
    AgentConnectionType["Http"] = "http";
    AgentConnectionType["Ws"] = "ws";
    AgentConnectionType["HttpQuorum"] = "httpQuorum";
    AgentConnectionType["HttpFallback"] = "httpFallback";
})(AgentConnectionType || (exports.AgentConnectionType = AgentConnectionType = {}));
var AgentConsensusType;
(function (AgentConsensusType) {
    AgentConsensusType["Fallback"] = "fallback";
    AgentConsensusType["Quorum"] = "quorum";
})(AgentConsensusType || (exports.AgentConsensusType = AgentConsensusType = {}));
var AgentLogLevel;
(function (AgentLogLevel) {
    AgentLogLevel["Off"] = "off";
    AgentLogLevel["Error"] = "error";
    AgentLogLevel["Warn"] = "warn";
    AgentLogLevel["Info"] = "info";
    AgentLogLevel["Debug"] = "debug";
    AgentLogLevel["Trace"] = "trace";
})(AgentLogLevel || (exports.AgentLogLevel = AgentLogLevel = {}));
var AgentLogFormat;
(function (AgentLogFormat) {
    AgentLogFormat["Json"] = "json";
    AgentLogFormat["Compact"] = "compact";
    AgentLogFormat["Full"] = "full";
    AgentLogFormat["Pretty"] = "pretty";
})(AgentLogFormat || (exports.AgentLogFormat = AgentLogFormat = {}));
var AgentIndexMode;
(function (AgentIndexMode) {
    AgentIndexMode["Block"] = "block";
    AgentIndexMode["Sequence"] = "sequence";
})(AgentIndexMode || (exports.AgentIndexMode = AgentIndexMode = {}));
exports.AgentSignerSchema = zod_1.z.union([
    zod_1.z
        .object({
        type: zod_1.z.literal('hexKey').optional(),
        key: customZodTypes_1.ZHash,
    })
        .describe('A local hex key'),
    zod_1.z
        .object({
        type: zod_1.z.literal('aws').optional(),
        id: zod_1.z.string().describe('The UUID identifying the AWS KMS key'),
        region: zod_1.z.string().describe('The AWS region'),
    })
        .describe('An AWS signer. Note that AWS credentials must be inserted into the env separately.'),
    zod_1.z
        .object({
        type: zod_1.z.literal('node'),
    })
        .describe('Assume the local node will sign on RPC calls automatically'),
]);
exports.AgentChainMetadataSchema = chainMetadataTypes_1.ChainMetadataSchema.merge(deploymentArtifacts_1.HyperlaneDeploymentArtifactsSchema).extend({
    customRpcUrls: zod_1.z
        .record(chainMetadataTypes_1.RpcUrlSchema.extend({
        priority: customZodTypes_1.ZNzUint.optional().describe('The priority of this RPC relative to the others defined. A larger value means it will be preferred. Only effects some AgentConsensusTypes.'),
    }))
        .refine((data) => Object.keys(data).length > 0, {
        message: 'Must specify at least one RPC url if not using the default rpcUrls.',
    })
        .optional()
        .describe('Specify a custom RPC endpoint configuration for this chain. If this is set, then none of the `rpcUrls` will be used for this chain. The key value can be any valid string.'),
    rpcConsensusType: zod_1.z
        .nativeEnum(AgentConsensusType)
        .describe('The consensus type to use when multiple RPCs are configured.')
        .optional(),
    signer: exports.AgentSignerSchema.optional().describe('The signer to use for this chain'),
    index: zod_1.z
        .object({
        from: customZodTypes_1.ZUint.optional().describe('The starting block from which to index events.'),
        chunk: customZodTypes_1.ZNzUint.optional().describe('The number of blocks to index at a time.'),
        // TODO(2214): I think we can always interpret this from the ProtocolType
        mode: zod_1.z
            .nativeEnum(AgentIndexMode)
            .optional()
            .describe('The indexing method to use for this chain; will attempt to choose a suitable default if not specified.'),
    })
        .optional(),
});
exports.AgentConfigSchema = zod_1.z.object({
    metricsPort: customZodTypes_1.ZNzUint.lte(65535)
        .optional()
        .describe('The port to expose prometheus metrics on. Accessible via `GET /metrics`.'),
    chains: zod_1.z
        .record(exports.AgentChainMetadataSchema)
        .describe('Chain metadata for all chains that the agent will index.')
        .superRefine((data, ctx) => {
        for (const c in data) {
            if (c != data[c].name) {
                ctx.addIssue({
                    message: `Chain name ${c} does not match chain name in metadata ${data[c].name}`,
                    code: zod_1.z.ZodIssueCode.custom,
                });
            }
        }
    }),
    defaultSigner: exports.AgentSignerSchema.optional().describe('Default signer to use for any chains that have not defined their own.'),
    defaultRpcConsensusType: zod_1.z
        .nativeEnum(AgentConsensusType)
        .describe('The default consensus type to use for any chains that have not defined their own.')
        .optional(),
    log: zod_1.z
        .object({
        format: zod_1.z
            .nativeEnum(AgentLogFormat)
            .optional()
            .describe('The format to use for tracing logs.'),
        level: zod_1.z
            .nativeEnum(AgentLogLevel)
            .optional()
            .describe("The log level to use for the agent's logs."),
    })
        .optional(),
});
const CommaSeperatedChainList = zod_1.z.string().regex(/^[a-z0-9]+(,[a-z0-9]+)*$/);
const CommaSeperatedDomainList = zod_1.z.string().regex(/^\d+(,\d+)*$/);
const GasPaymentEnforcementBaseSchema = zod_1.z.object({
    matchingList: matchingList_1.MatchingListSchema.optional().describe('An optional matching list, any message that matches will use this policy. By default all messages will match.'),
});
const GasPaymentEnforcementSchema = zod_1.z.array(zod_1.z.union([
    GasPaymentEnforcementBaseSchema.extend({
        type: zod_1.z.literal('none').optional(),
    }),
    GasPaymentEnforcementBaseSchema.extend({
        type: zod_1.z.literal('minimum').optional(),
        payment: customZodTypes_1.ZUWei,
    }),
    GasPaymentEnforcementBaseSchema.extend({
        type: zod_1.z.literal('onChainFeeQuoting'),
        gasFraction: zod_1.z
            .string()
            .regex(/^\d+ ?\/ ?[1-9]\d*$/)
            .optional(),
    }),
]));
exports.RelayerAgentConfigSchema = exports.AgentConfigSchema.extend({
    db: zod_1.z
        .string()
        .nonempty()
        .optional()
        .describe('The path to the relayer database.'),
    relayChains: CommaSeperatedChainList.describe('Comma seperated list of chains to relay messages between.'),
    gasPaymentEnforcement: zod_1.z
        .union([GasPaymentEnforcementSchema, zod_1.z.string().nonempty()])
        .optional()
        .describe('The gas payment enforcement configuration as JSON. Expects an ordered array of `GasPaymentEnforcementConfig`.'),
    whitelist: zod_1.z
        .union([matchingList_1.MatchingListSchema, zod_1.z.string().nonempty()])
        .optional()
        .describe('If no whitelist is provided ALL messages will be considered on the whitelist.'),
    blacklist: zod_1.z
        .union([matchingList_1.MatchingListSchema, zod_1.z.string().nonempty()])
        .optional()
        .describe('If no blacklist is provided ALL will be considered to not be on the blacklist.'),
    transactionGasLimit: customZodTypes_1.ZUWei.optional().describe('This is optional. If not specified, any amount of gas will be valid, otherwise this is the max allowed gas in wei to relay a transaction.'),
    skipTransactionGasLimitFor: CommaSeperatedDomainList.optional().describe('Comma separated List of chain names to skip applying the transaction gas limit to.'),
    allowLocalCheckpointSyncers: zod_1.z
        .boolean()
        .optional()
        .describe('If true, allows local storage based checkpoint syncers. Not intended for production use.'),
});
exports.ScraperAgentConfigSchema = exports.AgentConfigSchema.extend({
    db: zod_1.z.string().nonempty().describe('Database connection string'),
    chainsToScrape: CommaSeperatedChainList.describe('Comma separated list of chain names to scrape'),
});
exports.ValidatorAgentConfigSchema = exports.AgentConfigSchema.extend({
    db: zod_1.z
        .string()
        .nonempty()
        .optional()
        .describe('The path to the validator database.'),
    originChainName: zod_1.z
        .string()
        .nonempty()
        .describe('Name of the chain to validate messages on'),
    validator: exports.AgentSignerSchema.describe('The validator attestation signer'),
    checkpointSyncer: zod_1.z.discriminatedUnion('type', [
        zod_1.z
            .object({
            type: zod_1.z.literal('localStorage'),
            path: zod_1.z
                .string()
                .nonempty()
                .describe('Path to the local storage location'),
        })
            .describe('A local checkpoint syncer'),
        zod_1.z
            .object({
            type: zod_1.z.literal('s3'),
            bucket: zod_1.z.string().nonempty(),
            region: zod_1.z.string().nonempty(),
            folder: zod_1.z
                .string()
                .nonempty()
                .optional()
                .describe('The folder/key-prefix to use, defaults to the root of the bucket'),
        })
            .describe('A checkpoint syncer that uses S3'),
    ]),
    interval: customZodTypes_1.ZUint.optional().describe('How long to wait between checking for new checkpoints in seconds.'),
});
/**
 * Utilities for generating agent configs from metadata / artifacts.
 */
// Returns the new agent config shape that extends ChainMetadata
function buildAgentConfigNew(chains, multiProvider, addresses, startBlocks) {
    const configs = {};
    for (const chain of [...chains].sort()) {
        const metadata = multiProvider.getChainMetadata(chain);
        const config = {
            ...metadata,
            mailbox: addresses[chain].mailbox,
            interchainGasPaymaster: addresses[chain].interchainGasPaymaster,
            validatorAnnounce: addresses[chain].validatorAnnounce,
            index: {
                from: startBlocks[chain],
            },
        };
        configs[chain] = config;
    }
    return configs;
}
exports.buildAgentConfigNew = buildAgentConfigNew;
// Returns the current (but deprecated) agent config shape.
function buildAgentConfigDeprecated(chains, multiProvider, addresses, startBlocks) {
    const agentConfig = {
        chains: {},
    };
    for (const chain of [...chains].sort()) {
        const metadata = multiProvider.getChainMetadata(chain);
        const chainConfig = {
            name: chain,
            domain: metadata.chainId,
            addresses: {
                mailbox: addresses[chain].mailbox,
                interchainGasPaymaster: addresses[chain].interchainGasPaymaster,
                validatorAnnounce: addresses[chain].validatorAnnounce,
            },
            protocol: metadata.protocol,
            finalityBlocks: metadata.blocks?.reorgPeriod ?? 1,
        };
        chainConfig.index = {
            from: startBlocks[chain],
        };
        agentConfig.chains[chain] = chainConfig;
    }
    return agentConfig;
}
exports.buildAgentConfigDeprecated = buildAgentConfigDeprecated;
function buildAgentConfig(chains, multiProvider, addresses, startBlocks) {
    return {
        ...buildAgentConfigNew(chains, multiProvider, addresses, startBlocks),
        ...buildAgentConfigDeprecated(chains, multiProvider, addresses, startBlocks),
    };
}
exports.buildAgentConfig = buildAgentConfig;
//# sourceMappingURL=agentConfig.js.map