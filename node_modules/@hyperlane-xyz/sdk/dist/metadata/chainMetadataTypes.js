"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDomainId = exports.isValidChainMetadata = exports.ChainMetadataSchema = exports.RpcUrlSchema = exports.ExplorerFamily = void 0;
/**
 * The types defined here are the source of truth for chain metadata.
 * ANY CHANGES HERE NEED TO BE REFLECTED IN HYPERLANE-BASE CONFIG PARSING.
 */
const zod_1 = require("zod");
const utils_1 = require("@hyperlane-xyz/utils");
const customZodTypes_1 = require("./customZodTypes");
var ExplorerFamily;
(function (ExplorerFamily) {
    ExplorerFamily["Etherscan"] = "etherscan";
    ExplorerFamily["Blockscout"] = "blockscout";
    ExplorerFamily["Other"] = "other";
})(ExplorerFamily || (exports.ExplorerFamily = ExplorerFamily = {}));
exports.RpcUrlSchema = zod_1.z.object({
    http: zod_1.z
        .string()
        .url()
        .describe('The HTTP URL of the RPC endpoint (preferably HTTPS).'),
    webSocket: zod_1.z
        .string()
        .optional()
        .describe('The WSS URL if the endpoint also supports websockets.'),
    pagination: zod_1.z
        .object({
        maxBlockRange: customZodTypes_1.ZNzUint.optional().describe('The maximum range between block numbers for which the RPC can query data'),
        minBlockNumber: customZodTypes_1.ZUint.optional().describe('The absolute minimum block number that this RPC supports.'),
        maxBlockAge: customZodTypes_1.ZNzUint.optional().describe('The relative different from latest block that this RPC supports.'),
    })
        .optional()
        .describe('Limitations on the block range/age that can be queried.'),
    retry: zod_1.z
        .object({
        maxRequests: customZodTypes_1.ZNzUint.describe('The maximum number of requests to attempt before failing.'),
        baseRetryMs: customZodTypes_1.ZNzUint.describe('The base retry delay in milliseconds.'),
    })
        .optional()
        .describe('Default retry settings to be used by a provider such as MultiProvider.'),
});
/**
 * A collection of useful properties and settings for chains using Hyperlane
 * Specified as a Zod schema
 */
exports.ChainMetadataSchema = zod_1.z.object({
    protocol: zod_1.z
        .nativeEnum(utils_1.ProtocolType)
        .describe('The type of protocol used by this chain. See ProtocolType for valid values.'),
    chainId: customZodTypes_1.ZNzUint.describe(`The chainId of the chain. Uses EIP-155 for EVM chains`),
    domainId: customZodTypes_1.ZNzUint.optional().describe('The domainId of the chain, should generally default to `chainId`. Consumer of `ChainMetadata` should use this value if present, but otherwise fallback to `chainId`.'),
    name: zod_1.z
        .string()
        .regex(/^[a-z][a-z0-9]*$/)
        .describe('The unique string identifier of the chain, used as the key in ChainMap dictionaries.'),
    displayName: zod_1.z
        .string()
        .optional()
        .describe('Human-readable name of the chain.'),
    displayNameShort: zod_1.z
        .string()
        .optional()
        .describe('A shorter human-readable name of the chain for use in user interfaces.'),
    logoURI: zod_1.z
        .string()
        .optional()
        .describe('A URI to a logo image for this chain for use in user interfaces.'),
    nativeToken: zod_1.z
        .object({
        name: zod_1.z.string(),
        symbol: zod_1.z.string(),
        decimals: customZodTypes_1.ZUint.lt(256),
    })
        .optional()
        .describe('The metadata of the native token of the chain (e.g. ETH for Ethereum).'),
    rpcUrls: zod_1.z
        .array(exports.RpcUrlSchema)
        .nonempty()
        .describe('The list of RPC endpoints for interacting with the chain.'),
    blockExplorers: zod_1.z
        .array(zod_1.z.object({
        name: zod_1.z.string().describe('A human readable name for the explorer.'),
        url: zod_1.z.string().url().describe('The base URL for the explorer.'),
        apiUrl: zod_1.z
            .string()
            .url()
            .describe('The base URL for requests to the explorer API.'),
        apiKey: zod_1.z
            .string()
            .optional()
            .describe('An API key for the explorer (recommended for better reliability).'),
        family: zod_1.z
            .nativeEnum(ExplorerFamily)
            .optional()
            .describe('The type of the block explorer. See ExplorerFamily for valid values.'),
    }))
        .optional()
        .describe('A list of block explorers with data for this chain'),
    blocks: zod_1.z
        .object({
        confirmations: customZodTypes_1.ZUint.describe('Number of blocks to wait before considering a transaction confirmed.'),
        reorgPeriod: customZodTypes_1.ZUint.optional().describe('Number of blocks before a transaction has a near-zero chance of reverting.'),
        estimateBlockTime: zod_1.z
            .number()
            .positive()
            .finite()
            .optional()
            .describe('Rough estimate of time per block in seconds.'),
    })
        .optional()
        .describe('Block settings for the chain/deployment.'),
    transactionOverrides: zod_1.z
        .object({})
        .optional()
        .describe('Properties to include when forming transaction requests.'),
    gasCurrencyCoinGeckoId: zod_1.z
        .string()
        .optional()
        .describe('The ID on CoinGecko of the token used for gas payments.'),
    gnosisSafeTransactionServiceUrl: zod_1.z
        .string()
        .optional()
        .describe('The URL of the gnosis safe transaction service.'),
    isTestnet: zod_1.z
        .boolean()
        .optional()
        .describe('Whether the chain is considered a testnet or a mainnet.'),
});
function isValidChainMetadata(c) {
    return exports.ChainMetadataSchema.safeParse(c).success;
}
exports.isValidChainMetadata = isValidChainMetadata;
function getDomainId(chainMetadata) {
    return chainMetadata.domainId ?? chainMetadata.chainId;
}
exports.getDomainId = getDomainId;
//# sourceMappingURL=chainMetadataTypes.js.map