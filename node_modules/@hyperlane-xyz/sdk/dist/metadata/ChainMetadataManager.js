"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainMetadataManager = void 0;
const debug_1 = require("debug");
const utils_1 = require("@hyperlane-xyz/utils");
const chainMetadata_1 = require("../consts/chainMetadata");
const chainMetadataTypes_1 = require("./chainMetadataTypes");
/**
 * A set of utilities to manage chain metadata
 * Validates metadata on construction and provides useful methods
 * for interacting with the data
 */
class ChainMetadataManager {
    /**
     * Create a new ChainMetadataManager with the given chainMetadata,
     * or the SDK's default metadata if not provided
     */
    constructor(chainMetadata = chainMetadata_1.chainMetadata, options = {}) {
        this.metadata = {};
        Object.entries(chainMetadata).forEach(([key, cm]) => {
            if (key !== cm.name)
                throw new Error(`Chain name mismatch: Key was ${key}, but name is ${cm.name}`);
            this.addChain(cm);
        });
        this.logger = (0, debug_1.debug)(options?.loggerName || 'hyperlane:MetadataManager');
    }
    /**
     * Add a chain to the MultiProvider
     * @throws if chain's name or domain/chain ID collide
     */
    addChain(metadata) {
        if (!(0, chainMetadataTypes_1.isValidChainMetadata)(metadata))
            throw new Error(`Invalid chain metadata for ${metadata.name}`);
        // Ensure no two chains have overlapping names/domainIds/chainIds
        for (const chainMetadata of Object.values(this.metadata)) {
            const { name, chainId, domainId } = chainMetadata;
            if (name == metadata.name)
                throw new Error(`Duplicate chain name: ${name}`);
            // Chain and Domain Ids should be globally unique
            const idCollision = chainId == metadata.chainId ||
                domainId == metadata.chainId ||
                (metadata.domainId &&
                    (chainId == metadata.domainId || domainId === metadata.domainId));
            if (idCollision)
                throw new Error(`Chain/Domain id collision: ${name} and ${metadata.name}`);
        }
        this.metadata[metadata.name] = metadata;
    }
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    tryGetChainMetadata(chainNameOrId) {
        let chainMetadata;
        if ((0, utils_1.isNumeric)(chainNameOrId)) {
            // Should be chain id or domain id
            chainMetadata = Object.values(this.metadata).find((m) => m.chainId == chainNameOrId || m.domainId == chainNameOrId);
        }
        else if (typeof chainNameOrId === 'string') {
            // Should be chain name
            chainMetadata = this.metadata[chainNameOrId];
        }
        return chainMetadata || null;
    }
    /**
     * Get the metadata for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainMetadata(chainNameOrId) {
        const chainMetadata = this.tryGetChainMetadata(chainNameOrId);
        if (!chainMetadata)
            throw new Error(`No chain metadata set for ${chainNameOrId}`);
        return chainMetadata;
    }
    /**
     * Get the name for a given chain name, chain id, or domain id
     */
    tryGetChainName(chainNameOrId) {
        return this.tryGetChainMetadata(chainNameOrId)?.name ?? null;
    }
    /**
     * Get the name for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainName(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId).name;
    }
    /**
     * Get the names for all chains known to this MultiProvider
     */
    getKnownChainNames() {
        return Object.keys(this.metadata);
    }
    /**
     * Get the id for a given chain name, chain id, or domain id
     */
    tryGetChainId(chainNameOrId) {
        return this.tryGetChainMetadata(chainNameOrId)?.chainId ?? null;
    }
    /**
     * Get the id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getChainId(chainNameOrId) {
        return this.getChainMetadata(chainNameOrId).chainId;
    }
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownChainIds() {
        return Object.values(this.metadata).map((c) => c.chainId);
    }
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     */
    tryGetDomainId(chainNameOrId) {
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        return metadata?.domainId ?? metadata?.chainId ?? null;
    }
    /**
     * Get the domain id for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getDomainId(chainNameOrId) {
        const metadata = this.getChainMetadata(chainNameOrId);
        return (0, chainMetadataTypes_1.getDomainId)(metadata);
    }
    /**
     * Get the domain ids for a list of chain names, chain ids, or domain ids
     * @throws if any chain's metadata has not been set
     */
    getDomainIds(chainNamesOrIds) {
        return chainNamesOrIds.map((c) => this.getDomainId(c));
    }
    /**
     * Get the ids for all chains known to this MultiProvider
     */
    getKnownDomainIds() {
        return this.getKnownChainNames().map(this.getDomainId);
    }
    /**
     * Get chain names excluding given chain name
     */
    getRemoteChains(name) {
        return (0, utils_1.exclude)(name, this.getKnownChainNames());
    }
    /**
     * Run given function on all known chains
     */
    mapKnownChains(fn) {
        const result = {};
        for (const chain of this.getKnownChainNames()) {
            result[chain] = fn(chain);
        }
        return result;
    }
    /**
     * Get an RPC URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata has not been set
     */
    getRpcUrl(chainNameOrId) {
        const { rpcUrls } = this.getChainMetadata(chainNameOrId);
        if (!rpcUrls?.length || !rpcUrls[0].http)
            throw new Error(`No RPC URl configured for ${chainNameOrId}`);
        return rpcUrls[0].http;
    }
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerUrl(chainNameOrId) {
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        if (!metadata?.blockExplorers?.length)
            return null;
        const url = new URL(metadata.blockExplorers[0].url);
        // TODO move handling of these chain/protocol specific quirks to ChainMetadata
        if (metadata.protocol === utils_1.ProtocolType.Sealevel &&
            chainMetadata_1.solanaChainToClusterName[metadata.name]) {
            url.searchParams.set('cluster', chainMetadata_1.solanaChainToClusterName[metadata.name]);
        }
        return url.toString();
    }
    /**
     * Get a block explorer URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerUrl(chainNameOrId) {
        const url = this.tryGetExplorerUrl(chainNameOrId);
        if (!url)
            throw new Error(`No explorer url set for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer's API URL for a given chain name, chain id, or domain id
     */
    tryGetExplorerApiUrl(chainNameOrId) {
        const metadata = this.tryGetChainMetadata(chainNameOrId);
        const { protocol, blockExplorers } = metadata || {};
        if (protocol !== utils_1.ProtocolType.Ethereum)
            return null;
        if (!blockExplorers?.length || !blockExplorers[0].apiUrl)
            return null;
        const { apiUrl, apiKey } = blockExplorers[0];
        if (!apiKey)
            return apiUrl;
        const url = new URL(apiUrl);
        url.searchParams.set('apikey', apiKey);
        return url.toString();
    }
    /**
     * Get a block explorer API URL for a given chain name, chain id, or domain id
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerApiUrl(chainNameOrId) {
        const url = this.tryGetExplorerApiUrl(chainNameOrId);
        if (!url)
            throw new Error(`No explorer api url set for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer URL for given chain's tx
     */
    tryGetExplorerTxUrl(chainNameOrId, response) {
        const baseUrl = this.tryGetExplorerUrl(chainNameOrId);
        if (!baseUrl)
            return null;
        const chainName = this.getChainName(chainNameOrId);
        const urlPathStub = ['nautilus', 'proteustestnet'].includes(chainName)
            ? 'transaction'
            : 'tx';
        const url = new URL(baseUrl);
        url.pathname += `/${urlPathStub}/${response.hash}`;
        return url.toString();
    }
    /**
     * Get a block explorer URL for given chain's address
     */
    async tryGetExplorerAddressUrl(chainNameOrId, address) {
        if (!address)
            return null;
        const baseUrl = this.tryGetExplorerUrl(chainNameOrId);
        if (!baseUrl)
            return null;
        const url = new URL(baseUrl);
        url.pathname += `/address/${address}`;
        return url.toString();
    }
    /**
     * Get a block explorer URL for given chain's address
     * @throws if address or the chain's block explorer data has no been set
     */
    async getExplorerAddressUrl(chainNameOrId, address) {
        const url = await this.tryGetExplorerAddressUrl(chainNameOrId, address);
        if (!url)
            throw new Error(`Missing data for address url for ${chainNameOrId}`);
        return url;
    }
    /**
     * Get a block explorer URL for given chain's tx
     * @throws if chain's metadata or block explorer data has no been set
     */
    getExplorerTxUrl(chainNameOrId, response) {
        return `${this.getExplorerUrl(chainNameOrId)}/tx/${response.hash}`;
    }
    /**
     * Creates a new ChainMetadataManager with the extended metadata
     * @param additionalMetadata extra fields to add to the metadata for each chain
     * @returns a new ChainMetadataManager
     */
    extendChainMetadata(additionalMetadata) {
        const newMetadata = {};
        for (const [name, meta] of Object.entries(this.metadata)) {
            if (!additionalMetadata[name])
                throw new Error(`No additional data provided for chain ${name}`);
            newMetadata[name] = { ...meta, ...additionalMetadata[name] };
        }
        return new ChainMetadataManager(newMetadata);
    }
    /**
     * Create a new instance from the intersection
     * of current's chains and the provided chain list
     */
    intersect(chains, throwIfNotSubset = false) {
        const knownChains = this.getKnownChainNames();
        const intersection = [];
        for (const chain of chains) {
            if (knownChains.includes(chain))
                intersection.push(chain);
            else if (throwIfNotSubset)
                throw new Error(`Known chains does not include ${chain}`);
        }
        if (!intersection.length) {
            throw new Error(`No chains shared between known chains and list (${knownChains} and ${chains})`);
        }
        const intersectionMetadata = (0, utils_1.pick)(this.metadata, intersection);
        const result = new ChainMetadataManager(intersectionMetadata);
        return { intersection, result };
    }
}
exports.ChainMetadataManager = ChainMetadataManager;
//# sourceMappingURL=ChainMetadataManager.js.map