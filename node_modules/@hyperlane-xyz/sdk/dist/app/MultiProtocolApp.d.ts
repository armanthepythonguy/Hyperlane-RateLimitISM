/// <reference types="node" />
import { PublicKey } from '@solana/web3.js';
import debug from 'debug';
import { Address, ProtocolType } from '@hyperlane-xyz/utils';
import { ChainMetadata } from '../metadata/chainMetadataTypes';
import { MultiProtocolProvider } from '../providers/MultiProtocolProvider';
import { EthersV5Provider, SolanaWeb3Provider, TypedProvider } from '../providers/ProviderType';
import { ChainMap, ChainName } from '../types';
import { MultiGeneric } from '../utils/MultiGeneric';
/**
 * A minimal interface for an adapter that can be used with MultiProtocolApp
 * The purpose of adapters is to implement protocol-specific functionality
 * E.g. EvmRouterAdapter implements EVM-specific router functionality
 *   whereas SealevelRouterAdapter implements the same logic for Solana
 */
export declare abstract class BaseAppAdapter {
    readonly chainName: ChainName;
    readonly multiProvider: MultiProtocolProvider<any>;
    readonly addresses: Record<string, Address>;
    readonly logger: debug.Debugger;
    abstract readonly protocol: ProtocolType;
    constructor(chainName: ChainName, multiProvider: MultiProtocolProvider<any>, addresses: Record<string, Address>, logger?: debug.Debugger);
}
export type AdapterClassType<API> = new (chainName: ChainName, multiProvider: MultiProtocolProvider<any>, addresses: any, ...args: any) => API;
export declare class BaseEvmAdapter extends BaseAppAdapter {
    readonly protocol: ProtocolType;
    getProvider(): EthersV5Provider['provider'];
}
export declare class BaseSealevelAdapter extends BaseAppAdapter {
    readonly protocol: ProtocolType;
    getProvider(): SolanaWeb3Provider['provider'];
    static derivePda(seeds: Array<string | Buffer>, programId: string | PublicKey): PublicKey;
    derivePda(seeds: Array<string | Buffer>, programId: string | PublicKey): PublicKey;
}
/**
 * A version of HyperlaneApp that can support different
 * provider types across different protocol types.
 *
 * Intentionally minimal as it's meant to be extended.
 * Extend this class as needed to add useful methods/properties.
 *
 * @typeParam ContractAddrs - A map of contract names to addresses
 * @typeParam IAdapterApi - The type of the adapters for implementing the app's
 *   functionality across different protocols.
 *
 * @param multiProvider - A MultiProtocolProvider instance that MUST include the app's
 *   contract addresses in its chain metadata
 * @param logger - A logger instance
 *
 * @override protocolToAdapter - This should return an Adapter class for a given protocol type
 */
export declare abstract class MultiProtocolApp<IAdapterApi extends BaseAppAdapter, ContractAddrs extends Record<string, Address> = {}> extends MultiGeneric<ChainMetadata> {
    readonly multiProvider: MultiProtocolProvider;
    readonly addresses: ChainMap<ContractAddrs>;
    readonly logger: debug.Debugger;
    constructor(multiProvider: MultiProtocolProvider, addresses: ChainMap<ContractAddrs>, logger?: debug.Debugger);
    abstract protocolToAdapter(protocol: ProtocolType): AdapterClassType<IAdapterApi>;
    adapter(chain: ChainName): IAdapterApi;
    adapters(): ChainMap<IAdapterApi>;
    adapterMap<Output>(fn: (n: ChainName, a: IAdapterApi) => Promise<Output>): Promise<ChainMap<Output>>;
    metadata(chain: ChainName): ChainMetadata;
    protocol(chain: ChainName): ProtocolType;
    provider(chain: ChainName): TypedProvider;
}
//# sourceMappingURL=MultiProtocolApp.d.ts.map