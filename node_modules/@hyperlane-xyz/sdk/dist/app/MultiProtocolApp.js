"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiProtocolApp = exports.BaseSealevelAdapter = exports.BaseEvmAdapter = exports.BaseAppAdapter = void 0;
const web3_js_1 = require("@solana/web3.js");
const debug_1 = __importDefault(require("debug"));
const utils_1 = require("@hyperlane-xyz/utils");
const MultiGeneric_1 = require("../utils/MultiGeneric");
/**
 * A minimal interface for an adapter that can be used with MultiProtocolApp
 * The purpose of adapters is to implement protocol-specific functionality
 * E.g. EvmRouterAdapter implements EVM-specific router functionality
 *   whereas SealevelRouterAdapter implements the same logic for Solana
 */
class BaseAppAdapter {
    constructor(chainName, multiProvider, addresses, logger = (0, debug_1.default)(`hyperlane:AppAdapter`)) {
        this.chainName = chainName;
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        this.logger = logger;
    }
}
exports.BaseAppAdapter = BaseAppAdapter;
class BaseEvmAdapter extends BaseAppAdapter {
    constructor() {
        super(...arguments);
        this.protocol = utils_1.ProtocolType.Ethereum;
    }
    getProvider() {
        return this.multiProvider.getEthersV5Provider(this.chainName);
    }
}
exports.BaseEvmAdapter = BaseEvmAdapter;
class BaseSealevelAdapter extends BaseAppAdapter {
    constructor() {
        super(...arguments);
        this.protocol = utils_1.ProtocolType.Sealevel;
    }
    getProvider() {
        return this.multiProvider.getSolanaWeb3Provider(this.chainName);
    }
    static derivePda(seeds, programId) {
        const [pda] = web3_js_1.PublicKey.findProgramAddressSync(seeds.map((s) => Buffer.from(s)), new web3_js_1.PublicKey(programId));
        return pda;
    }
    // An dynamic alias for static method above for convenience
    derivePda(seeds, programId) {
        return BaseSealevelAdapter.derivePda(seeds, programId);
    }
}
exports.BaseSealevelAdapter = BaseSealevelAdapter;
/**
 * A version of HyperlaneApp that can support different
 * provider types across different protocol types.
 *
 * Intentionally minimal as it's meant to be extended.
 * Extend this class as needed to add useful methods/properties.
 *
 * @typeParam ContractAddrs - A map of contract names to addresses
 * @typeParam IAdapterApi - The type of the adapters for implementing the app's
 *   functionality across different protocols.
 *
 * @param multiProvider - A MultiProtocolProvider instance that MUST include the app's
 *   contract addresses in its chain metadata
 * @param logger - A logger instance
 *
 * @override protocolToAdapter - This should return an Adapter class for a given protocol type
 */
class MultiProtocolApp extends MultiGeneric_1.MultiGeneric {
    constructor(multiProvider, addresses, logger = (0, debug_1.default)('hyperlane:MultiProtocolApp')) {
        super(multiProvider.metadata);
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        this.logger = logger;
    }
    // Subclasses may want to override this to provide adapters more arguments
    adapter(chain) {
        const Adapter = this.protocolToAdapter(this.protocol(chain));
        return new Adapter(chain, this.multiProvider, this.addresses[chain]);
    }
    adapters() {
        return this.map((chain, _) => this.adapter(chain));
    }
    adapterMap(fn) {
        return (0, utils_1.promiseObjAll)((0, utils_1.objMap)(this.adapters(), fn));
    }
    metadata(chain) {
        return this.get(chain);
    }
    protocol(chain) {
        return this.metadata(chain).protocol;
    }
    provider(chain) {
        return this.multiProvider.getProvider(chain);
    }
}
exports.MultiProtocolApp = MultiProtocolApp;
//# sourceMappingURL=MultiProtocolApp.js.map