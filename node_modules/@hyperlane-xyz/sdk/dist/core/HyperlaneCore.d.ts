import { ethers } from 'ethers';
import { HyperlaneApp } from '../app/HyperlaneApp';
import { HyperlaneEnvironment } from '../consts/environments';
import { HyperlaneAddressesMap } from '../contracts/types';
import { MultiProvider } from '../providers/MultiProvider';
import { ChainName } from '../types';
import { CoreFactories } from './contracts';
import { DispatchedMessage } from './types';
export declare class HyperlaneCore extends HyperlaneApp<CoreFactories> {
    static fromEnvironment<Env extends HyperlaneEnvironment>(env: Env, multiProvider: MultiProvider): HyperlaneCore;
    static fromAddressesMap(addressesMap: HyperlaneAddressesMap<any>, multiProvider: MultiProvider): HyperlaneCore;
    protected getDestination(message: DispatchedMessage): ChainName;
    protected waitForProcessReceipt(message: DispatchedMessage): Promise<ethers.ContractReceipt>;
    waitForMessageIdProcessed(messageId: string, destination: ChainName, delayMs?: number, maxAttempts?: number): Promise<void>;
    waitForMessageProcessing(sourceTx: ethers.ContractReceipt): Promise<ethers.ContractReceipt[]>;
    waitForMessageProcessed(sourceTx: ethers.ContractReceipt, delay?: number, maxAttempts?: number): Promise<void>;
    getDispatchedMessages(sourceTx: ethers.ContractReceipt): DispatchedMessage[];
    static getDispatchedMessages(sourceTx: ethers.ContractReceipt): DispatchedMessage[];
}
//# sourceMappingURL=HyperlaneCore.d.ts.map