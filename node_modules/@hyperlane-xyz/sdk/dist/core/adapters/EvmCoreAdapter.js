"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmCoreAdapter = void 0;
const core_1 = require("@hyperlane-xyz/core");
const MultiProtocolApp_1 = require("../../app/MultiProtocolApp");
const ProviderType_1 = require("../../providers/ProviderType");
const HyperlaneCore_1 = require("../HyperlaneCore");
// This adapter just routes to the HyperlaneCore
// Which implements the needed functionality for EVM chains
// TODO deprecate HyperlaneCore and replace all evm-specific classes with adapters
class EvmCoreAdapter extends MultiProtocolApp_1.BaseEvmAdapter {
    constructor(chainName, multiProvider, addresses) {
        super(chainName, multiProvider, addresses);
        this.chainName = chainName;
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        const contractsMap = {
            [chainName]: {
                mailbox: core_1.Mailbox__factory.connect(addresses.mailbox, multiProvider.getEthersV5Provider(chainName)),
            },
        }; // Core only uses mailbox so cast to keep adapter interface simple
        this.core = new HyperlaneCore_1.HyperlaneCore(contractsMap, multiProvider.toMultiProvider());
    }
    extractMessageIds(sourceTx) {
        if (sourceTx.type !== ProviderType_1.ProviderType.EthersV5) {
            throw new Error(`Unsupported provider type for EvmCoreAdapter ${sourceTx.type}`);
        }
        const messages = this.core.getDispatchedMessages(sourceTx.receipt);
        return messages.map(({ id, parsed }) => ({
            messageId: id,
            destination: this.multiProvider.getChainName(parsed.destination),
        }));
    }
    waitForMessageProcessed(messageId, destination, delayMs, maxAttempts) {
        return this.core.waitForMessageIdProcessed(messageId, destination, delayMs, maxAttempts);
    }
}
exports.EvmCoreAdapter = EvmCoreAdapter;
//# sourceMappingURL=EvmCoreAdapter.js.map