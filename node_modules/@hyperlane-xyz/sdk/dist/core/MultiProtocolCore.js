"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiProtocolCore = void 0;
const debug_1 = __importDefault(require("debug"));
const utils_1 = require("@hyperlane-xyz/utils");
const MultiProtocolApp_1 = require("../app/MultiProtocolApp");
const environments_1 = require("../consts/environments");
const EvmCoreAdapter_1 = require("./adapters/EvmCoreAdapter");
const SealevelCoreAdapter_1 = require("./adapters/SealevelCoreAdapter");
class MultiProtocolCore extends MultiProtocolApp_1.MultiProtocolApp {
    constructor(multiProvider, addresses, logger = (0, debug_1.default)('hyperlane:MultiProtocolCore')) {
        super(multiProvider, addresses, logger);
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        this.logger = logger;
    }
    static fromEnvironment(env, multiProvider) {
        const envAddresses = environments_1.hyperlaneEnvironments[env];
        if (!envAddresses) {
            throw new Error(`No addresses found for ${env}`);
        }
        return MultiProtocolCore.fromAddressesMap(envAddresses, multiProvider);
    }
    static fromAddressesMap(addressesMap, multiProvider) {
        return new MultiProtocolCore(multiProvider.intersect(Object.keys(addressesMap)).result, addressesMap);
    }
    protocolToAdapter(protocol) {
        if (protocol === utils_1.ProtocolType.Ethereum)
            return EvmCoreAdapter_1.EvmCoreAdapter;
        if (protocol === utils_1.ProtocolType.Sealevel)
            return SealevelCoreAdapter_1.SealevelCoreAdapter;
        throw new Error(`No adapter for protocol ${protocol}`);
    }
    waitForMessagesProcessed(origin, destination, sourceTx, delayMs, maxAttempts) {
        const messages = this.adapter(origin).extractMessageIds(sourceTx);
        return Promise.all(messages.map((msg) => this.adapter(destination).waitForMessageProcessed(msg.messageId, msg.destination, delayMs, maxAttempts)));
    }
}
exports.MultiProtocolCore = MultiProtocolCore;
//# sourceMappingURL=MultiProtocolCore.js.map