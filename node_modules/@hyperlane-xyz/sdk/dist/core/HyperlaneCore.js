"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperlaneCore = void 0;
const core_1 = require("@hyperlane-xyz/core");
const utils_1 = require("@hyperlane-xyz/utils");
const HyperlaneApp_1 = require("../app/HyperlaneApp");
const environments_1 = require("../consts/environments");
const contracts_1 = require("../contracts/contracts");
const contracts_2 = require("./contracts");
class HyperlaneCore extends HyperlaneApp_1.HyperlaneApp {
    static fromEnvironment(env, multiProvider) {
        const envAddresses = environments_1.hyperlaneEnvironments[env];
        if (!envAddresses) {
            throw new Error(`No addresses found for ${env}`);
        }
        return HyperlaneCore.fromAddressesMap(envAddresses, multiProvider);
    }
    static fromAddressesMap(addressesMap, multiProvider) {
        const helper = (0, contracts_1.appFromAddressesMapHelper)(addressesMap, contracts_2.coreFactories, multiProvider);
        return new HyperlaneCore(helper.contractsMap, helper.multiProvider);
    }
    getDestination(message) {
        return this.multiProvider.getChainName(message.parsed.destination);
    }
    waitForProcessReceipt(message) {
        const id = (0, utils_1.messageId)(message.message);
        const destinationChain = this.getDestination(message);
        const mailbox = this.contractsMap[destinationChain].mailbox;
        const filter = mailbox.filters.ProcessId(id);
        return new Promise((resolve, reject) => {
            mailbox.once(filter, (emittedId, event) => {
                if (id !== emittedId) {
                    reject(`Expected message id ${id} but got ${emittedId}`);
                }
                resolve(this.multiProvider.handleTx(destinationChain, event.getTransaction()));
            });
        });
    }
    async waitForMessageIdProcessed(messageId, destination, delayMs, maxAttempts) {
        await (0, utils_1.pollAsync)(async () => {
            this.logger(`Checking if message ${messageId} was processed`);
            const mailbox = this.contractsMap[destination].mailbox;
            const delivered = await mailbox.delivered(messageId);
            if (delivered) {
                this.logger(`Message ${messageId} was processed`);
                return;
            }
            else {
                throw new Error(`Message ${messageId} not yet processed`);
            }
        }, delayMs, maxAttempts);
        return;
    }
    waitForMessageProcessing(sourceTx) {
        const messages = HyperlaneCore.getDispatchedMessages(sourceTx);
        return Promise.all(messages.map((msg) => this.waitForProcessReceipt(msg)));
    }
    // TODO consider renaming this, all the waitForMessage* methods are confusing
    async waitForMessageProcessed(sourceTx, delay, maxAttempts) {
        const messages = HyperlaneCore.getDispatchedMessages(sourceTx);
        await Promise.all(messages.map((msg) => this.waitForMessageIdProcessed(msg.id, this.getDestination(msg), delay, maxAttempts)));
    }
    // Redundant with static method but keeping for backwards compatibility
    getDispatchedMessages(sourceTx) {
        return HyperlaneCore.getDispatchedMessages(sourceTx);
    }
    static getDispatchedMessages(sourceTx) {
        const mailbox = core_1.Mailbox__factory.createInterface();
        const dispatchLogs = sourceTx.logs
            .map((log) => {
            try {
                return mailbox.parseLog(log);
            }
            catch (e) {
                return undefined;
            }
        })
            .filter((log) => !!log && log.name === 'Dispatch');
        return dispatchLogs.map((log) => {
            const message = log.args['message'];
            const parsed = (0, utils_1.parseMessage)(message);
            const id = (0, utils_1.messageId)(message);
            return { id, message, parsed };
        });
    }
}
exports.HyperlaneCore = HyperlaneCore;
//# sourceMappingURL=HyperlaneCore.js.map