import debug from 'debug';
import { ProtocolType } from '@hyperlane-xyz/utils';
import { AdapterClassType, MultiProtocolApp } from '../app/MultiProtocolApp';
import { HyperlaneEnvironment } from '../consts/environments';
import { MultiProtocolProvider } from '../providers/MultiProtocolProvider';
import { TypedTransactionReceipt } from '../providers/ProviderType';
import { ChainMap, ChainName } from '../types';
import { ICoreAdapter } from './adapters/types';
import { CoreAddresses } from './contracts';
export declare class MultiProtocolCore extends MultiProtocolApp<ICoreAdapter, CoreAddresses> {
    readonly multiProvider: MultiProtocolProvider;
    readonly addresses: ChainMap<CoreAddresses>;
    readonly logger: debug.Debugger;
    constructor(multiProvider: MultiProtocolProvider, addresses: ChainMap<CoreAddresses>, logger?: debug.Debugger);
    static fromEnvironment<Env extends HyperlaneEnvironment>(env: Env, multiProvider: MultiProtocolProvider): MultiProtocolCore;
    static fromAddressesMap(addressesMap: ChainMap<CoreAddresses>, multiProvider: MultiProtocolProvider): MultiProtocolCore;
    protocolToAdapter(protocol: ProtocolType): AdapterClassType<ICoreAdapter>;
    waitForMessagesProcessed(origin: ChainName, destination: ChainName, sourceTx: TypedTransactionReceipt, delayMs?: number, maxAttempts?: number): Promise<void[]>;
}
//# sourceMappingURL=MultiProtocolCore.d.ts.map