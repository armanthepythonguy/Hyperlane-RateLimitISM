"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.strip0x = exports.ensure0x = exports.convertToProtocolAddress = exports.bytesToProtocolAddress = exports.addressToByteHexString = exports.addressToBytes = exports.addressToBytesSol = exports.addressToBytesEvm = exports.bytes32ToAddress = exports.addressToBytes32 = exports.capitalizeAddress = exports.shortenAddress = exports.isZeroishAddress = exports.isValidTransactionHash = exports.isValidTransactionHashSealevel = exports.isValidTransactionHashEvm = exports.eqAddress = exports.eqAddressSol = exports.eqAddressEvm = exports.normalizeAddress = exports.normalizeAddressSealevel = exports.normalizeAddressEvm = exports.isValidAddress = exports.isValidAddressSealevel = exports.isValidAddressEvm = exports.getAddressProtocolType = exports.isAddressSealevel = exports.isAddressEvm = void 0;
const web3_js_1 = require("@solana/web3.js");
const ethers_1 = require("ethers");
const types_1 = require("./types");
const EVM_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
const SEALEVEL_ADDRESS_REGEX = /^[a-zA-Z0-9]{36,44}$/;
const EVM_TX_HASH_REGEX = /^0x([A-Fa-f0-9]{64})$/;
const SEALEVEL_TX_HASH_REGEX = /^[a-zA-Z1-9]{88}$/;
const ZEROISH_ADDRESS_REGEX = /^(0x)?0*$/;
function isAddressEvm(address) {
    return EVM_ADDRESS_REGEX.test(address);
}
exports.isAddressEvm = isAddressEvm;
function isAddressSealevel(address) {
    return SEALEVEL_ADDRESS_REGEX.test(address);
}
exports.isAddressSealevel = isAddressSealevel;
function getAddressProtocolType(address) {
    if (!address)
        return undefined;
    if (isAddressEvm(address)) {
        return types_1.ProtocolType.Ethereum;
    }
    else if (isAddressSealevel(address)) {
        return types_1.ProtocolType.Sealevel;
    }
    else {
        return undefined;
    }
}
exports.getAddressProtocolType = getAddressProtocolType;
function routeAddressUtil(evmFn, sealevelFn, fallback, param, protocol) {
    protocol = protocol || getAddressProtocolType(param);
    if (protocol === types_1.ProtocolType.Ethereum) {
        return evmFn(param);
    }
    else if (protocol === types_1.ProtocolType.Sealevel) {
        return sealevelFn(param);
    }
    else {
        return fallback;
    }
}
// Slower than isAddressEvm above but actually validates content and checksum
function isValidAddressEvm(address) {
    // Need to catch because ethers' isAddress throws in some cases (bad checksum)
    try {
        const isValid = address && ethers_1.utils.isAddress(address);
        return !!isValid;
    }
    catch (error) {
        return false;
    }
}
exports.isValidAddressEvm = isValidAddressEvm;
// Slower than isAddressSealevel above but actually validates content and checksum
function isValidAddressSealevel(address) {
    try {
        const isValid = address && new web3_js_1.PublicKey(address).toBase58();
        return !!isValid;
    }
    catch (error) {
        return false;
    }
}
exports.isValidAddressSealevel = isValidAddressSealevel;
function isValidAddress(address, protocol) {
    return routeAddressUtil(isValidAddressEvm, isValidAddressSealevel, false, address, protocol);
}
exports.isValidAddress = isValidAddress;
function normalizeAddressEvm(address) {
    if (isZeroishAddress(address))
        return address;
    try {
        return ethers_1.utils.getAddress(address);
    }
    catch (error) {
        return address;
    }
}
exports.normalizeAddressEvm = normalizeAddressEvm;
function normalizeAddressSealevel(address) {
    if (isZeroishAddress(address))
        return address;
    try {
        return new web3_js_1.PublicKey(address).toBase58();
    }
    catch (error) {
        return address;
    }
}
exports.normalizeAddressSealevel = normalizeAddressSealevel;
function normalizeAddress(address, protocol) {
    return routeAddressUtil(normalizeAddressEvm, normalizeAddressSealevel, address, address, protocol);
}
exports.normalizeAddress = normalizeAddress;
function eqAddressEvm(a1, a2) {
    return normalizeAddressEvm(a1) === normalizeAddressEvm(a2);
}
exports.eqAddressEvm = eqAddressEvm;
function eqAddressSol(a1, a2) {
    return normalizeAddressSealevel(a1) === normalizeAddressSealevel(a2);
}
exports.eqAddressSol = eqAddressSol;
function eqAddress(a1, a2) {
    const p1 = getAddressProtocolType(a1);
    const p2 = getAddressProtocolType(a2);
    if (p1 !== p2)
        return false;
    return routeAddressUtil((_a1) => eqAddressEvm(_a1, a2), (_a1) => eqAddressSol(_a1, a2), false, a1, p1);
}
exports.eqAddress = eqAddress;
function isValidTransactionHashEvm(input) {
    return EVM_TX_HASH_REGEX.test(input);
}
exports.isValidTransactionHashEvm = isValidTransactionHashEvm;
function isValidTransactionHashSealevel(input) {
    return SEALEVEL_TX_HASH_REGEX.test(input);
}
exports.isValidTransactionHashSealevel = isValidTransactionHashSealevel;
function isValidTransactionHash(input, protocol) {
    return routeAddressUtil(isValidTransactionHashEvm, isValidTransactionHashSealevel, false, input, protocol);
}
exports.isValidTransactionHash = isValidTransactionHash;
function isZeroishAddress(address) {
    return ZEROISH_ADDRESS_REGEX.test(address);
}
exports.isZeroishAddress = isZeroishAddress;
function shortenAddress(address, capitalize) {
    if (!address)
        return '';
    if (address.length < 8)
        return address;
    const normalized = normalizeAddress(address);
    const shortened = normalized.substring(0, 5) +
        '...' +
        normalized.substring(normalized.length - 4);
    return capitalize ? capitalizeAddress(shortened) : shortened;
}
exports.shortenAddress = shortenAddress;
function capitalizeAddress(address) {
    if (address.startsWith('0x'))
        return '0x' + address.substring(2).toUpperCase();
    else
        return address.toUpperCase();
}
exports.capitalizeAddress = capitalizeAddress;
function addressToBytes32(address) {
    return ethers_1.utils
        .hexZeroPad(ethers_1.utils.hexStripZeros(address), 32)
        .toLowerCase();
}
exports.addressToBytes32 = addressToBytes32;
function bytes32ToAddress(bytes32) {
    return ethers_1.utils.getAddress(bytes32.slice(-40));
}
exports.bytes32ToAddress = bytes32ToAddress;
function addressToBytesEvm(address) {
    const addrBytes32 = addressToBytes32(address);
    return Buffer.from(addrBytes32.substring(2), 'hex');
}
exports.addressToBytesEvm = addressToBytesEvm;
function addressToBytesSol(address) {
    return new web3_js_1.PublicKey(address).toBytes();
}
exports.addressToBytesSol = addressToBytesSol;
function addressToBytes(address, protocol) {
    return routeAddressUtil(addressToBytesEvm, addressToBytesSol, new Uint8Array(), address, protocol);
}
exports.addressToBytes = addressToBytes;
function addressToByteHexString(address, protocol) {
    return '0x' + Buffer.from(addressToBytes(address, protocol)).toString('hex');
}
exports.addressToByteHexString = addressToByteHexString;
function bytesToProtocolAddress(bytes, toProtocol) {
    if (toProtocol === types_1.ProtocolType.Sealevel) {
        return new web3_js_1.PublicKey(bytes).toBase58();
    }
    else if (toProtocol === types_1.ProtocolType.Ethereum) {
        return bytes32ToAddress(bytes.toString('hex'));
    }
    else {
        throw new Error(`Unsupported protocol for address ${toProtocol}`);
    }
}
exports.bytesToProtocolAddress = bytesToProtocolAddress;
function convertToProtocolAddress(address, protocol) {
    const currentProtocol = getAddressProtocolType(address);
    if (currentProtocol === protocol)
        return address;
    if (currentProtocol === types_1.ProtocolType.Ethereum &&
        protocol === types_1.ProtocolType.Sealevel) {
        return new web3_js_1.PublicKey(addressToBytes(address, types_1.ProtocolType.Ethereum)).toBase58();
    }
    else if (currentProtocol === types_1.ProtocolType.Sealevel &&
        protocol === types_1.ProtocolType.Ethereum) {
        return bytes32ToAddress(Buffer.from(addressToBytes(address, types_1.ProtocolType.Sealevel)).toString('hex'));
    }
    else {
        throw new Error(`Unsupported protocol combination ${currentProtocol} -> ${protocol}`);
    }
}
exports.convertToProtocolAddress = convertToProtocolAddress;
function ensure0x(hexstr) {
    return hexstr.startsWith('0x') ? hexstr : `0x${hexstr}`;
}
exports.ensure0x = ensure0x;
function strip0x(hexstr) {
    return hexstr.startsWith('0x') ? hexstr.slice(2) : hexstr;
}
exports.strip0x = strip0x;
//# sourceMappingURL=addresses.js.map