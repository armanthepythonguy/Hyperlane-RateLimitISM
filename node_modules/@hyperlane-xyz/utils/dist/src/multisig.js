"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatLegacyMultisigIsmMetadata = exports.parseLegacyMultisigIsmMetadata = void 0;
const ethers_1 = require("ethers");
const addresses_1 = require("./addresses");
const parseLegacyMultisigIsmMetadata = (metadata) => {
    const MERKLE_ROOT_OFFSET = 0;
    const MERKLE_INDEX_OFFSET = 32;
    const ORIGIN_MAILBOX_OFFSET = 36;
    const MERKLE_PROOF_OFFSET = 68;
    const THRESHOLD_OFFSET = 1092;
    const SIGNATURES_OFFSET = 1093;
    const SIGNATURE_LENGTH = 65;
    const buf = Buffer.from(ethers_1.utils.arrayify(metadata));
    const checkpointRoot = ethers_1.utils.hexlify(buf.slice(MERKLE_ROOT_OFFSET, MERKLE_INDEX_OFFSET));
    const checkpointIndex = ethers_1.BigNumber.from(ethers_1.utils.hexlify(buf.slice(MERKLE_INDEX_OFFSET, ORIGIN_MAILBOX_OFFSET))).toNumber();
    const originMailbox = ethers_1.utils.hexlify(buf.slice(ORIGIN_MAILBOX_OFFSET, MERKLE_PROOF_OFFSET));
    const parseBytesArray = (start, count, size) => {
        return [...Array(count).keys()].map((i) => ethers_1.utils.hexlify(buf.slice(start + size * i, start + size * (i + 1))));
    };
    const proof = parseBytesArray(MERKLE_PROOF_OFFSET, 32, 32);
    const threshold = ethers_1.BigNumber.from(ethers_1.utils.hexlify(buf.slice(THRESHOLD_OFFSET, SIGNATURES_OFFSET))).toNumber();
    const signatures = parseBytesArray(SIGNATURES_OFFSET, threshold, SIGNATURE_LENGTH);
    const VALIDATORS_OFFSET = SIGNATURES_OFFSET + threshold * SIGNATURE_LENGTH;
    const addressesCount = buf.slice(VALIDATORS_OFFSET).length / 32;
    const validators = parseBytesArray(VALIDATORS_OFFSET, addressesCount, 32);
    return {
        checkpointRoot,
        checkpointIndex,
        originMailbox,
        proof,
        signatures,
        validators,
    };
};
exports.parseLegacyMultisigIsmMetadata = parseLegacyMultisigIsmMetadata;
const formatLegacyMultisigIsmMetadata = (metadata) => {
    return ethers_1.utils.solidityPack([
        'bytes32',
        'uint32',
        'bytes32',
        'bytes32[32]',
        'uint8',
        'bytes',
        'address[]',
    ], [
        metadata.checkpointRoot,
        metadata.checkpointIndex,
        (0, addresses_1.addressToBytes32)(metadata.originMailbox),
        metadata.proof,
        metadata.signatures.length,
        ethers_1.utils.hexConcat(metadata.signatures),
        metadata.validators,
    ]);
};
exports.formatLegacyMultisigIsmMetadata = formatLegacyMultisigIsmMetadata;
//# sourceMappingURL=multisig.js.map