"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDecimals = exports.eqAmountApproximate = exports.tryParseAmount = exports.toWei = exports.fromWeiRounded = exports.fromWei = void 0;
const units_1 = require("@ethersproject/units");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const DEFAULT_MIN_ROUNDED_VALUE = 0.00001;
const DEFAULT_DISPLAY_DECIMALS = 4;
const DEFAULT_TOKEN_DECIMALS = 18;
function fromWei(value, decimals = DEFAULT_TOKEN_DECIMALS) {
    if (!value)
        return 0;
    const valueString = value.toString().trim();
    const flooredValue = new bignumber_js_1.default(valueString).toFixed(0, bignumber_js_1.default.ROUND_FLOOR);
    return parseFloat((0, units_1.formatUnits)(flooredValue, decimals));
}
exports.fromWei = fromWei;
// Similar to fromWei above but rounds to set number of decimals
// with a minimum floor, configured per token
function fromWeiRounded(value, decimals = DEFAULT_TOKEN_DECIMALS, roundDownIfSmall = true) {
    if (!value)
        return '0';
    const flooredValue = new bignumber_js_1.default(value).toFixed(0, bignumber_js_1.default.ROUND_FLOOR);
    const amount = new bignumber_js_1.default((0, units_1.formatUnits)(flooredValue, decimals));
    if (amount.isZero())
        return '0';
    // If amount is less than min value
    if (amount.lt(DEFAULT_MIN_ROUNDED_VALUE)) {
        if (roundDownIfSmall)
            return '0';
        return amount.toString(10);
    }
    const displayDecimals = amount.gte(10000) ? 2 : DEFAULT_DISPLAY_DECIMALS;
    return amount.toFixed(displayDecimals).toString();
}
exports.fromWeiRounded = fromWeiRounded;
function toWei(value, decimals = DEFAULT_TOKEN_DECIMALS) {
    if (!value)
        return new bignumber_js_1.default(0);
    // First convert to a BigNumber, and then call `toString` with the
    // explicit radix 10 such that the result is formatted as a base-10 string
    // and not in scientific notation.
    const valueBN = new bignumber_js_1.default(value);
    const valueString = valueBN.toString(10).trim();
    const components = valueString.split('.');
    if (components.length === 1) {
        return new bignumber_js_1.default((0, units_1.parseUnits)(valueString, decimals).toString());
    }
    else if (components.length === 2) {
        const trimmedFraction = components[1].substring(0, decimals);
        return new bignumber_js_1.default((0, units_1.parseUnits)(`${components[0]}.${trimmedFraction}`, decimals).toString());
    }
    else {
        throw new Error(`Cannot convert ${valueString} to wei`);
    }
}
exports.toWei = toWei;
function tryParseAmount(value) {
    try {
        if (!value)
            return null;
        const parsed = new bignumber_js_1.default(value);
        if (!parsed || parsed.isNaN() || !parsed.isFinite())
            return null;
        else
            return parsed;
    }
    catch (error) {
        return null;
    }
}
exports.tryParseAmount = tryParseAmount;
// Checks if an amount is equal of nearly equal to balance within a small margin of error
// Necessary because amounts in the UI are often rounded
function eqAmountApproximate(amountInWei1, amountInWei2) {
    const minValueWei = toWei(DEFAULT_MIN_ROUNDED_VALUE);
    // Is difference btwn amount and balance less than min amount shown for token
    return amountInWei1.minus(amountInWei2).abs().lt(minValueWei);
}
exports.eqAmountApproximate = eqAmountApproximate;
/**
 * Converts a value with `fromDecimals` decimals to a value with `toDecimals` decimals.
 * Incurs a loss of precision when `fromDecimals` > `toDecimals`.
 * @param fromDecimals The number of decimals `value` has.
 * @param toDecimals The number of decimals to convert `value` to.
 * @param value The value to convert.
 * @returns `value` represented with `toDecimals` decimals.
 */
function convertDecimals(fromDecimals, toDecimals, value) {
    const amount = new bignumber_js_1.default(value);
    if (fromDecimals === toDecimals)
        return amount;
    else if (fromDecimals > toDecimals) {
        const difference = fromDecimals - toDecimals;
        return amount
            .div(new bignumber_js_1.default(10).pow(difference))
            .integerValue(bignumber_js_1.default.ROUND_FLOOR);
    }
    // fromDecimals < toDecimals
    else {
        const difference = toDecimals - fromDecimals;
        return amount.times(new bignumber_js_1.default(10).pow(difference));
    }
}
exports.convertDecimals = convertDecimals;
//# sourceMappingURL=amount.js.map