"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayToObject = exports.invertKeysAndValues = exports.objMerge = exports.pick = exports.promiseObjAll = exports.objFilter = exports.objMap = exports.objMapEntries = exports.deepEquals = exports.isObject = void 0;
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
exports.isObject = isObject;
function deepEquals(v1, v2) {
    return JSON.stringify(v1) === JSON.stringify(v2);
}
exports.deepEquals = deepEquals;
function objMapEntries(obj, func) {
    return Object.entries(obj).map(([k, v]) => [k, func(k, v)]);
}
exports.objMapEntries = objMapEntries;
// Map over the values of the object
function objMap(obj, func) {
    return Object.fromEntries(objMapEntries(obj, func));
}
exports.objMap = objMap;
function objFilter(obj, func) {
    return Object.fromEntries(Object.entries(obj).filter(([k, v]) => func(k, v)));
}
exports.objFilter = objFilter;
// promiseObjectAll :: {k: Promise a} -> Promise {k: a}
function promiseObjAll(obj) {
    const promiseList = Object.entries(obj).map(([name, promise]) => promise.then((result) => [name, result]));
    return Promise.all(promiseList).then(Object.fromEntries);
}
exports.promiseObjAll = promiseObjAll;
// Get the subset of the object from key list
function pick(obj, keys) {
    const ret = {};
    const objKeys = Object.keys(obj);
    for (const key of keys) {
        if (objKeys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
}
exports.pick = pick;
// Recursively merges b into a
// Where there are conflicts, b takes priority over a
function objMerge(a, b, max_depth = 10) {
    if (max_depth === 0) {
        throw new Error('objMerge tried to go too deep');
    }
    if (isObject(a) && isObject(b)) {
        const ret = {};
        const aKeys = new Set(Object.keys(a));
        const bKeys = new Set(Object.keys(b));
        const allKeys = new Set([...aKeys, ...bKeys]);
        for (const key of allKeys.values()) {
            if (aKeys.has(key) && bKeys.has(key)) {
                ret[key] = objMerge(a[key], b[key], max_depth - 1);
            }
            else if (aKeys.has(key)) {
                ret[key] = a[key];
            }
            else {
                ret[key] = b[key];
            }
        }
        return ret;
    }
    else {
        return b ? b : a;
    }
}
exports.objMerge = objMerge;
function invertKeysAndValues(data) {
    return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));
}
exports.invertKeysAndValues = invertKeysAndValues;
// Returns an object with the keys as values from an array and value set to true
function arrayToObject(keys, val = true) {
    return keys.reduce((result, k) => {
        result[k] = val;
        return result;
    }, {});
}
exports.arrayToObject = arrayToObject;
//# sourceMappingURL=objects.js.map