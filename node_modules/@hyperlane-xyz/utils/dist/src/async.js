"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pollAsync = exports.retryAsync = exports.runWithTimeout = exports.timeout = exports.sleep = void 0;
/**
 * Return a promise that resolves in ms milliseconds.
 * @param ms Time to wait
 */
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
/**
 * Wait up to a given amount of time, and throw an error if the promise does not resolve in time.
 * @param promise The promise to timeout on.
 * @param timeoutMs How long to wait for the promise in milliseconds.
 * @param message The error message if a timeout occurs.
 */
function timeout(promise, timeoutMs, message = 'Timeout reached') {
    if (!timeoutMs || timeoutMs <= 0)
        return promise;
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error(message));
        }, timeoutMs);
        promise.then(resolve).catch(reject);
    });
}
exports.timeout = timeout;
/**
 * Run a callback with a timeout.
 * @param timeoutMs How long to wait for the promise in milliseconds.
 * @param callback The callback to run.
 * @returns callback return value
 */
async function runWithTimeout(timeoutMs, callback) {
    let timeout;
    const timeoutProm = new Promise((_, reject) => (timeout = setTimeout(() => reject(new Error(`Timed out in ${timeoutMs}ms.`)), timeoutMs)));
    const ret = await Promise.race([callback(), timeoutProm]);
    // @ts-ignore timeout gets set immediately by the promise constructor
    clearTimeout(timeout);
    return ret;
}
exports.runWithTimeout = runWithTimeout;
/**
 * Retries an async function if it raises an exception,
 *   using exponential backoff.
 * @param runner callback to run
 * @param attempts max number of attempts
 * @param baseRetryMs base delay between attempts
 * @returns runner return value
 */
async function retryAsync(runner, attempts = 5, baseRetryMs = 50) {
    let saveError;
    for (let i = 0; i < attempts; i++) {
        try {
            const result = await runner();
            return result;
        }
        catch (error) {
            saveError = error;
            await sleep(baseRetryMs * 2 ** i);
        }
    }
    throw saveError;
}
exports.retryAsync = retryAsync;
/**
 * Run a callback with a timeout, and retry if the callback throws an error.
 * @param runner callback to run
 * @param delayMs base delay between attempts
 * @param maxAttempts maximum number of attempts
 * @returns runner return value
 */
async function pollAsync(runner, delayMs = 500, maxAttempts = undefined) {
    let attempts = 0;
    let saveError;
    while (!maxAttempts || attempts < maxAttempts) {
        try {
            const ret = await runner();
            return ret;
        }
        catch (error) {
            saveError = error;
            attempts += 1;
            await sleep(delayMs);
        }
    }
    throw saveError;
}
exports.pollAsync = pollAsync;
//# sourceMappingURL=async.js.map