"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMessage = exports.messageId = exports.formatMessage = void 0;
const ethers_1 = require("ethers");
const addresses_1 = require("./addresses");
/**
 * JS Implementation of solidity/contracts/libs/Message.sol#formatMessage
 * @returns Hex string of the packed message
 */
const formatMessage = (version, nonce, originDomain, senderAddr, destinationDomain, recipientAddr, body) => {
    senderAddr = (0, addresses_1.addressToBytes32)(senderAddr);
    recipientAddr = (0, addresses_1.addressToBytes32)(recipientAddr);
    return ethers_1.ethers.utils.solidityPack(['uint8', 'uint32', 'uint32', 'bytes32', 'uint32', 'bytes32', 'bytes'], [
        version,
        nonce,
        originDomain,
        senderAddr,
        destinationDomain,
        recipientAddr,
        body,
    ]);
};
exports.formatMessage = formatMessage;
/**
 * Get ID given message bytes
 * @param message Hex string of the packed message (see formatMessage)
 * @returns Hex string of message id
 */
function messageId(message) {
    return ethers_1.ethers.utils.solidityKeccak256(['bytes'], [message]);
}
exports.messageId = messageId;
/**
 * Parse a serialized Hyperlane message from raw bytes.
 *
 * @param message
 * @returns
 */
function parseMessage(message) {
    const VERSION_OFFSET = 0;
    const NONCE_OFFSET = 1;
    const ORIGIN_OFFSET = 5;
    const SENDER_OFFSET = 9;
    const DESTINATION_OFFSET = 41;
    const RECIPIENT_OFFSET = 45;
    const BODY_OFFSET = 77;
    const buf = Buffer.from(ethers_1.utils.arrayify(message));
    const version = buf.readUint8(VERSION_OFFSET);
    const nonce = buf.readUInt32BE(NONCE_OFFSET);
    const origin = buf.readUInt32BE(ORIGIN_OFFSET);
    const sender = ethers_1.utils.hexlify(buf.slice(SENDER_OFFSET, DESTINATION_OFFSET));
    const destination = buf.readUInt32BE(DESTINATION_OFFSET);
    const recipient = ethers_1.utils.hexlify(buf.slice(RECIPIENT_OFFSET, BODY_OFFSET));
    const body = ethers_1.utils.hexlify(buf.slice(BODY_OFFSET));
    return { version, nonce, origin, sender, destination, recipient, body };
}
exports.parseMessage = parseMessage;
//# sourceMappingURL=messages.js.map